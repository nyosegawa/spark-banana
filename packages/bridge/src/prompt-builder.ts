import type { Annotation, BananaSuggestion, SparkPlanVariant } from './types';

/**
 * アノテーションからプロンプトを構築する
 *
 * 方針: 迅速に作業するよう指示しつつ、要素情報はすべて詳細に渡す
 */
export function buildPrompt(annotation: Annotation): string {
  const el = annotation.element;
  const lines: string[] = [];

  lines.push(`# UI Fix Request`);
  lines.push(``);
  lines.push(`> **URGENT**: Apply this fix immediately. Work fast, be precise, do not hesitate.`);
  lines.push(``);

  // ユーザーのコメント（最も重要）
  lines.push(`## User Request`);
  lines.push(``);
  lines.push(`"${annotation.comment}"`);
  lines.push(``);

  if (annotation.selectedText) {
    lines.push(`**Selected text**: "${annotation.selectedText}"`);
    lines.push(``);
  }

  // ターゲット要素の詳細情報
  lines.push(`## Target Element`);
  lines.push(``);
  lines.push(`The user clicked on a specific instance of this element. Unless they explicitly say "only this one", apply the fix to **all matching elements** of the same type.`);
  lines.push(``);
  lines.push(`| Property | Value |`);
  lines.push(`|----------|-------|`);
  lines.push(`| **Tag** | \`<${el.tagName}>\` |`);
  lines.push(`| **Generic Selector** | \`${el.genericSelector}\` |`);
  lines.push(`| **Unique Selector** | \`${el.selector}\` |`);
  lines.push(`| **Full DOM Path** | \`${el.fullPath}\` |`);
  lines.push(`| **Parent** | \`${el.parentSelector}\` |`);

  if (el.reactComponents) {
    lines.push(`| **React Components** | \`${el.reactComponents}\` |`);
  }

  if (el.cssClasses.length > 0) {
    lines.push(`| **CSS Classes** | ${el.cssClasses.map(c => `\`.${c}\``).join(', ')} |`);
  }

  // 属性情報
  const attrEntries = Object.entries(el.attributes);
  if (attrEntries.length > 0) {
    for (const [key, value] of attrEntries) {
      lines.push(`| **attr: ${key}** | \`${value.slice(0, 200)}\` |`);
    }
  }

  if (el.accessibility) {
    lines.push(`| **Accessibility** | ${el.accessibility} |`);
  }

  // バウンディングボックス
  const bb = el.boundingBox;
  lines.push(`| **Bounding Box** | x=${bb.x}, y=${bb.y}, w=${bb.width}, h=${bb.height} |`);

  lines.push(``);

  // Computed Styles
  if (el.computedStyles) {
    lines.push(`### Current Computed Styles`);
    lines.push(``);
    lines.push('```');
    lines.push(el.computedStyles);
    lines.push('```');
    lines.push(``);
  }

  // テキスト内容
  if (el.textContent) {
    lines.push(`### Element Text Content`);
    lines.push(``);
    lines.push('```');
    lines.push(el.textContent.slice(0, 500));
    lines.push('```');
    lines.push(``);
  }

  // 周辺テキスト
  if (el.nearbyText) {
    lines.push(`### Nearby Text (context)`);
    lines.push(``);
    lines.push('```');
    lines.push(el.nearbyText.slice(0, 500));
    lines.push('```');
    lines.push(``);
  }

  // ルール
  lines.push(`## Rules`);
  lines.push(``);
  lines.push(`1. **React Component names are the most important clue for finding source files.** Use \`rg\` to search for the component names shown above (e.g. \`rg "function NavButton"\` or \`rg "const NavButton"\`).`);
  lines.push(`2. Also search for **CSS class names** or **text content** to locate the source file.`);
  lines.push(`3. Use the **Generic Selector** (not the Unique Selector) when writing CSS rules, so the fix applies to all matching elements.`);
  lines.push(`4. Change **only** what the user asked for — do not refactor, add comments, or modify unrelated code.`);
  lines.push(`5. If the source file is ambiguous, cross-reference React Components, Full DOM Path, CSS Classes, and Parent selector to narrow it down.`);
  lines.push(`6. The **Computed Styles** section shows the element's current visual state — use it to understand what needs changing.`);
  lines.push(`7. After making changes, briefly confirm what you changed.`);

  return lines.join('\n');
}

/**
 * Build a prompt for Codex to apply a Banana suggestion.
 * Includes paths to original and target images so Codex can visually compare them.
 */
export function buildBananaApplyPrompt(
  suggestion: BananaSuggestion,
  instruction: string,
  region: { x: number; y: number; width: number; height: number },
  originalImagePath: string,
  targetImagePath: string,
  regionElements?: string,
): string {
  const lines: string[] = [];

  lines.push(`# UI Improvement — Match Target Design`);
  lines.push(``);
  lines.push(`> **URGENT**: Compare the two images below and modify the code so the UI matches the TARGET image. Do not refactor or modify anything else.`);
  lines.push(``);

  lines.push(`## Images`);
  lines.push(``);
  lines.push(`**Original UI** (current state): ${originalImagePath}`);
  lines.push(`**Target UI** (what it should look like): ${targetImagePath}`);
  lines.push(``);
  lines.push(`Look at both images carefully. The target was generated by an AI designer based on the user's instruction below.`);
  lines.push(``);

  lines.push(`## User Instruction`);
  lines.push(``);
  lines.push(`"${instruction}"`);
  lines.push(``);

  if (suggestion.description) {
    lines.push(`## AI Designer Notes`);
    lines.push(``);
    lines.push(suggestion.description);
    lines.push(``);
  }

  if (regionElements) {
    lines.push(`## Target DOM Elements`);
    lines.push(``);
    lines.push(`The following elements were found in the selected region (x=${region.x}, y=${region.y}, ${region.width}x${region.height}):`);
    lines.push(``);
    lines.push('```');
    lines.push(regionElements);
    lines.push('```');
    lines.push(``);
    lines.push(`Focus your changes on these elements and their source files.`);
    lines.push(``);
  }

  lines.push(`## Rules`);
  lines.push(``);
  lines.push(`1. **Look at both images** to understand what changed visually.`);
  lines.push(`2. **Search for source files by component name first.** Use \`rg\` to search for React/Vue/Svelte component names.`);
  lines.push(`3. **Search by CSS class names** or visible text content as fallback.`);
  lines.push(`4. **Apply ONLY the changes needed** to make the UI match the target image.`);
  lines.push(`5. If multiple files need changing (component + CSS), change them all in one pass.`);
  lines.push(`6. After making changes, briefly confirm what you changed.`);

  return lines.join('\n');
}

/**
 * spark+plan モード用プロンプト: 3バリアント生成
 */
export function buildSparkPlanPrompt(annotation: Annotation): string {
  const el = annotation.element;
  const lines: string[] = [];

  lines.push(`# UI Plan Mode — Generate 3 Switchable Variants`);
  lines.push(``);
  lines.push(`> Generate 3 different approaches to implement the user's request. Each variant must be switchable at runtime using the pattern below.`);
  lines.push(``);

  lines.push(`## User Request`);
  lines.push(``);
  lines.push(`"${annotation.comment}"`);
  lines.push(``);

  if (annotation.selectedText) {
    lines.push(`**Selected text**: "${annotation.selectedText}"`);
    lines.push(``);
  }

  // Target element (same format as buildPrompt)
  lines.push(`## Target Element`);
  lines.push(``);
  lines.push(`| Property | Value |`);
  lines.push(`|----------|-------|`);
  lines.push(`| **Tag** | \`<${el.tagName}>\` |`);
  lines.push(`| **Generic Selector** | \`${el.genericSelector}\` |`);
  lines.push(`| **Unique Selector** | \`${el.selector}\` |`);
  lines.push(`| **Full DOM Path** | \`${el.fullPath}\` |`);
  lines.push(`| **Parent** | \`${el.parentSelector}\` |`);
  if (el.reactComponents) {
    lines.push(`| **React Components** | \`${el.reactComponents}\` |`);
  }
  if (el.cssClasses.length > 0) {
    lines.push(`| **CSS Classes** | ${el.cssClasses.map(c => `\`.${c}\``).join(', ')} |`);
  }
  const attrEntries = Object.entries(el.attributes);
  for (const [key, value] of attrEntries) {
    lines.push(`| **attr: ${key}** | \`${value.slice(0, 200)}\` |`);
  }
  if (el.accessibility) {
    lines.push(`| **Accessibility** | ${el.accessibility} |`);
  }
  const bb = el.boundingBox;
  lines.push(`| **Bounding Box** | x=${bb.x}, y=${bb.y}, w=${bb.width}, h=${bb.height} |`);
  lines.push(``);

  if (el.computedStyles) {
    lines.push(`### Current Computed Styles`);
    lines.push(``);
    lines.push('```');
    lines.push(el.computedStyles);
    lines.push('```');
    lines.push(``);
  }

  if (el.nearbyText) {
    lines.push(`### Nearby Text (context)`);
    lines.push(``);
    lines.push('```');
    lines.push(el.nearbyText.slice(0, 500));
    lines.push('```');
    lines.push(``);
  }

  lines.push(`## Instructions`);
  lines.push(``);
  lines.push(`1. Find the source file for the target element.`);
  lines.push(`2. Create 3 variant implementations of the requested change:`);
  lines.push(`   - **Variant 0**: Faithful, conservative implementation`);
  lines.push(`   - **Variant 1**: Creative, bolder approach`);
  lines.push(`   - **Variant 2**: Minimal, refined approach`);
  lines.push(`3. Add this runtime switcher code to the component:`);
  lines.push(``);
  lines.push('```tsx');
  lines.push(`const [__sparkVariant, __setSparkVariant] = useState(() => {`);
  lines.push(`  return (window as any).__sparkPlanVariant ?? 0;`);
  lines.push(`});`);
  lines.push(`useEffect(() => {`);
  lines.push(`  const handler = (e: Event) => __setSparkVariant((e as CustomEvent).detail);`);
  lines.push(`  window.addEventListener('spark-plan-variant', handler);`);
  lines.push(`  return () => window.removeEventListener('spark-plan-variant', handler);`);
  lines.push(`}, []);`);
  lines.push('```');
  lines.push(``);
  lines.push(`4. Use \`__sparkVariant\` to conditionally render each variant (0, 1, or 2).`);
  lines.push(`5. **IMPORTANT**: After implementing, output this exact JSON block in your final response text:`);
  lines.push(``);
  lines.push('```');
  lines.push(`__SPARK_PLAN_META__`);
  lines.push(`[`);
  lines.push(`  { "index": 0, "title": "Conservative", "description": "..." },`);
  lines.push(`  { "index": 1, "title": "Bold", "description": "..." },`);
  lines.push(`  { "index": 2, "title": "Minimal", "description": "..." }`);
  lines.push(`]`);
  lines.push(`__SPARK_PLAN_META__`);
  lines.push('```');
  lines.push(``);
  lines.push(`6. Default to variant 0 on initial render.`);
  lines.push(`7. Change ONLY the target element — do not modify unrelated code.`);

  return lines.join('\n');
}

/**
 * spark+plan フラット化プロンプト: 選択バリアントのみ残す
 */
export function buildSparkPlanApplyPrompt(variantIndex: number): string {
  const lines: string[] = [];

  lines.push(`# Apply Spark Plan Variant ${variantIndex}`);
  lines.push(``);
  lines.push(`> The user has chosen variant ${variantIndex}. Remove the switcher mechanism and keep only that variant's implementation.`);
  lines.push(``);
  lines.push(`## Instructions`);
  lines.push(``);
  lines.push(`1. Find the file that contains the \`__sparkVariant\` / \`__setSparkVariant\` state and the \`spark-plan-variant\` event listener.`);
  lines.push(`2. Remove the \`useState\` hook for \`__sparkVariant\` and the \`useEffect\` listener.`);
  lines.push(`3. Remove the conditional rendering logic — keep ONLY variant ${variantIndex}'s code path.`);
  lines.push(`4. Remove any \`__SPARK_PLAN_META__\` comment blocks.`);
  lines.push(`5. Clean up unused imports.`);
  lines.push(`6. The result should look like a normal, clean implementation with no trace of the variant system.`);

  return lines.join('\n');
}

/**
 * spark+plan キャンセルプロンプト: 元に戻す
 */
export function buildSparkPlanCancelPrompt(): string {
  return `# Cancel Spark Plan Mode

> The user cancelled plan mode. Undo ALL changes you made in the previous turn.

## Instructions

1. Find the file you modified (it contains \`__sparkVariant\` / \`__setSparkVariant\`).
2. Revert ALL changes — remove the variant code, the switcher, everything you added.
3. Restore the file to its original state before plan mode.
4. Do not leave any trace of the variant system.`;
}
